#include <iostream>

int sum(int x, int y) { return x + y; };
int sub(int x, int y) { return x - y; };

int(*f) (int, int);

int main()
{

//    X = 9 + n;    //
//    Y = 10 + n;   //
//    Z = 11 + n;   //
//    S = 1.0 + n;  //
//    Пусть n=0     //

    bool fl = false;
    bool tr = true;
    char h = 'h';
    wchar_t т = L'т';

    short Xa = 9; 
    short Xe = -9;

    //    9(10)=9(16)
    //    9/16=0 (остаток 9)

    //  перевод в 2ный прямой код
    //  9/2=4 остаток     1
    //  4/2 = 2 остаток   0
    //  2/2 = 1 остаток   0
    //  1/2 = 0 остаток   1
    //  Представление положительного числа 00001001
    //  Обратный код 11110110
    //  Дополнительный код 11110111
    //  Перевод в 16ную систему счисления: F7 (1111-F, 0111-7) + FF(16)=11(2), 
    //  тк отрицательное значение.
    
    short Xx = 0x9;




//SHORT SHORT SHORT 

    //MIN
//перевод в 2ный прямой код

//    32768 / 2 = 16384 остаток   0 
//    16384 / 2 = 8192 остаток   0
//    8192 / 2 = 4096 остаток   0
//    4096 / 2 = 2048 остаток   0
//    2048 / 2 = 1024 остаток   0
//    1024 / 2 = 512 остаток   0
//    512 / 2 = 256 остаток   0
//    256 / 2 = 128 остаток   0
//    128 / 2 = 64 остаток   0
//    64 / 2 = 32 остаток   0
//    32 / 2 = 16 остаток   0
//    16 / 2 = 8 остаток   0
//    8 / 2 = 4 остаток   0
//    4 / 2 = 2 остаток   0
//    2 / 2 = 1 остаток   0
//    1 / 2 = 0 остаток   1

//  Представление положительного числа 1000000000000000
//  Обратный код 0111111111111111
//  Дополнительный код 1000000000000000
//  Перевод в 16ную систему счисления: 8000

    //MAX
//  Представление положительного числа 0111111111111111
//  Перевод в 16ную систему счисления: 7FFF

    int A = 0x12AB;
    int B = 0xAB12;
    short ShMin = 0x8000;
//самое малое число типа short =-32768 (10) = 8000 (16)
    short ShMax = 0x7FFF;      
//самое большое число типа short =32767 = 7FFF(16)




//UNSIGNED SHORT UNSIGNED SHORT UNSIGNED SHORT

    //MAX
//      65535/16=4095 остаток      15=F
//       4095 / 16 = 255 остаток   15 = F
//        255 / 16 = 15 остаток    15 = F
//          15 / 16 = 0 остаток    15 = F

    unsigned short USMax = 0xFFFF;
//  самое большое число типа unsigned short = 65535 = FFFF(16)
    unsigned short USMin =0x0 ;
//  самое малое число типа unsigned short =0 (10) = 0 (16) 

    int Ya = 10; //00 00 00 0A
    int Ye = -10; //FF FF FF F6

    //    10(10)=A(16)
    //    10/16=0 остаток   10=A

    /* 10 / 2 = 5 остаток   0
        5 / 2 = 2 остаток   1
        2 / 2 = 1 остаток   0
        1 / 2 = 0 остаток   1 */
    //Представление положительного числа 00001010
    //Обратный код 11110101
    //Дополнительный код 11110110
    // 11110110=F6 (+FF FF FF)



// INT  INT  INT

    //MAX
// Представление положительного числа: 0111 1111 1111 1111 1111 1111 1111 1111 (2)
// Перевод в 16ную систему счисления: 7F FF FF FF (16)

    //MIN
//  Представление положительного числа 10 000 000 000 000 000 000 000 000 000 000
//  Обратный код 01111111111111111111111111111111
//  Дополнительный код 10000000000000000000000000000000
//  Перевод в 16ную систему счисления: 80000000

    int IMIN = 0x80000000;
    //самое малое число типа int = -2147483648 (10) = 80 000 000 (16)
    int IMAX = 0x7FFFFFFF;
    //самое большое число типа int = 2147483647 (10) =7F FF FF FF (16)




// UNSIGNED INT   UNSIGNED INT    UNSIGNED INT

    //MAX
//  4294967295 / 16 = 268435455 остаток   15 = F
//  268435455 / 16 = 16777215 остаток   15 = F
//  16777215 / 16 = 1048575 остаток   15 = F
//  1048575 / 16 = 65535 остаток   15 = F
//  65535 / 16 = 4095 остаток   15 = F
//  4095 / 16 = 255 остаток   15 = F
//  255 / 16 = 15 остаток   15 = F
//  15 / 16 = 0 остаток   15 = F


    unsigned int UIMax = 0xFFFFFFFF;
    //самое большое число типа unsigned int =  4294967295 (10) = FF FFF FFF (16)
    unsigned int UIMin = 0x0;
    //самое малое число типа unsigned int = 0 (10) = 0(16)


    long Za = 11; //00 00 00 0b
    long Ze = -11; //ff ff ff f5

    //  11(10)=B(16)
    //  11/16=0 остаток   11=B

    //  перевод в 2ный прямой код
    //  11/2=5 остаток   1
    //  5 / 2 = 2 остаток   1
    //  2 / 2 = 1 остаток   0
    //  1 / 2 = 0 остаток   1

    //Представление положительного числа 00001011
    //Обратный код 11110100
    //Дополнительный код 11110101
    //11110101=F5 (+FF FF FF)


//LONG    LONG    LONG

    int LMin = 0x80000000;
//самое малое число типа long = -2147483648 (10) = 80 000 000(16)
    int LMax = 0x7FFFFFFF;
//самое большое число типа long =  2147483648 (10) = 7F FF FF FF(16)



//UNSIGNED INT   UNSIGNED INT   UNSIGNED INT

    unsigned int ULLittle = 0xFFFFFFFF; 
//самое малон число типа unsigned long = 0 (10) = 0 (16)
    unsigned int ULBig = 0x0;
//самое большое число типа unsigned long =  4294967295 (10) = FF FFF FFF (16)



//FLOAT  FLOAT  FLOAT

    float f1 = 2.000f; //40000000 (16)

    // 10.000 (2) -> 
    // 1.0000(+1) -> 
    // 128(к 127 (+1), чтобы не вводить ещё один бит знака)(10) = 10000000(2) ->
    // Для перевода необходимо умножить разряд числа на соответствующую ему степень разряда:
    // 00000000000000000000000 = 222 * 0 + 221 * 0 + 220 * 0 + 219 * 0 + 218 * 0 + 217 * 0 + 216 * 0 + 215 * 0 + 214 * 0 + 213 * 0 + 212 * 0 + 211 * 0 + 210 * 0 + 29 * 0 + 28 * 0 + 27 * 0 + 26 * 0 + 25 * 0 + 24 * 0 + 23 * 0 + 22 * 0 + 21 * 0 + 20 * 0 = 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 = 0
    // В десятичном коде мантисса выражается числом 0
    // В результате число 2.000 представленное в IEEE 754 c одинарной точностью равно 01000000000000000000000000000000.
    //  0100 0000 0000 0000 0000 0000 0000 0000(2) = 40000000 (16)

    float f2 = -2.000f; //C0000000 (16)
    // 10.000 (2)
    // 1.0000
    // 00000000000000000000000 = 222*0 + 221*0 + 220*0 + 219*0 + 218*0 + 217*0 + 216*0 + 215*0 + 214*0 + 213*0 + 212*0 + 211*0 + 210*0 + 29*0 + 28*0 + 27*0 + 26*0 + 25*0 + 24*0 + 23*0 + 22*0 + 21*0 + 20*0 = 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 = 0
    // число -2.000 представленное в IEEE 754 c одинарной точностью равно 11000000000000000000000000000000.
    // 100 0000 0000 0000 0000 0000 0000 0000 (2) = C0000000 (16)

    float f3 = f1 / 0;    //1.#INF
    float f4 = f2 / 0;    //-1.#INF
    float f5 = f3 + f4;   //-1.#IND

    double L = 3.0;

    float Sa = 1.0;
    float Se = -1.0;

    char *ph = &h;
    wchar_t *рт = &т;
    short *pXa = &Xa;
    int *pYa = &Ya;
    float *pSa = &Sa;    
    double* pL = &L;

    ph += 3;
    рт += 3;
    pXa += 3;
    pYa += 3;
    pSa += 3;
    pL += 3;

    char &pH = h;
    wchar_t &рТ = т;
    short &pXA = Xa;
    int &pYA = Ya;
    float &pSA = Sa;
    double& pLl = L;

/////////////////////////////////////////////////

    f = sum;
    int x = f(5, 3);
    f = sub;
    int y = f(5, 3);

    return 0;

}